Modularization(모듈화)

프로그램은 모듈이라고 불리는 자율적인 부분으로 구성되어야 한다.
다양한 모듈은 정확한 관계를 통해 서로 연관되어있다.

모듈이란 서로 밀접하게 연관된 패키지들과 리소스들의 그룹이다.

특징
- Service exported : 메서드가 무엇을 인식하는지
- An interface : 해당 서비스를 내보내는 방식 -> 메서드 헤더
- Imported services : 클라이언트가 사용하는 모듈의 서비스
- An internal structure : 모듈이 어떻게 구현되는지

모듈화를 사용하면 할 수 있는 것

- 요청된 문제를 해결하는 데 필요한 모듈을 정의한다.
- 우리는 이러한 모듈이 어떻게 관련되어 있는지 정의 한다.
- 각 모듈을 다른 모듈과 독립적으로 개발한다.

-> 이러한 방식으로 프로그램 처리를 단순화 할 수 있고 품질을 향상 시킬 수 있다.
 - readability of the program
 - extensibility (확장성)
 - reusability of parts (다양한 목적으로 프로그램 일부 재사용)

Abstraction

모듈화는 추상화 개념과 밀접하게 결합되어 있다.

유형
- Abstraction of operations : 어떻게 해야 할지가 아닌 무엇을 수행해야 하는지에 집중
	-> method를 통해 실현
- Abstraction on object : 
	1. 유사한 객체(동일한 속성을 가진 객체)를 클래스로 그룹화한다.
	 ex) 소나타, 아반떼, 토레스 -> 차 (그룹화)
	2. 객체의 관련 속성, 특히 객체가 지원하는 작업을 설정

Static method (정적 메서드)

- 정적 메서드는 호출 객체가 없는 메서드(클래스에 정의됨) 입니다.

Public static resultType methodName(formal parameter)
Static : 메서드가 정적임을 나타냄.
resultType : 반화한 결과의 탑입을 정해주는 것을 나타냄.

- 반환된 결과는 메소드에서 호출된 값이다.

메서드 호출에는 메서드 인수로 사용해야 하는 formal parameter가 포함된다. 
이러한 parameter를 메서드 정의 헤더에 나타나는 formal parameter와 구별하기 위해 actual parameter 라 한다.

public static String duplicate(String pf) { <- formal parameter
        return pf + ", " + pf;
    }
    public static void main(String[] args) {
        String s;
        s = duplicate("pippo"+ "&" + "toplino"); <- actual parameter
        System.out.println(s); 
    }

1. formal parameter 가  "pippo"+ "&" + "toplino” 문자열을 나타내는 객체에 대한 참조로 초기화 된다.
2. return을 통해 String 값을 반환한다.
3. Formal parameter와 local variable에 대한 메모리가 해제된다.  -> formal parameter에 해당하는 메모리 위치가 해제 됩니다.
4. 이제 실행은 메서드 호출에 의해 멈춘 지점부터 계속된다.

Local variable 
 메소드 내의 있는 변수를 local variable이라 한다.
- Scope (범위) : 지역 변수의 범위(int형)
- lifetime (수명) : 다음 메서드가 호출되기 전까지 유지된다.
- 

Method Overloading
- 메서드 이름이 같은 두 개의 메서드는 존재 할 수 없다. 하지만 파라미터의 값이 다르다면 사용할 수 있다 -> 메서드 오버로딩이라 한다.

Abstraction on objects

- 유사한 객체를 클래스로 그룹화한다.
- 객체가 하는 작업과 관련된 속성을 설정한다.(이것을 위해 추상화한다.)

Instance Variable(인스턴스 변수)
- 클래스 내부의 있는 static이 들어가지 않은 field variable이다.
Instance Method
- 클래스의 객체에게 호출되어 작업을 수행 할 수 있다.

Data field : 객체의 내부 구조를 나타내는데 사용된다.
Operation field : 클래스 기능을 구현하는데 사용.

Rules for accessing the field of a class

- 클라이언트가 관심을 갖는 클래스 기능에 해당하는 메서드는 public으로 선언
- 인스턴스 변수와 보조 메서드, 즉 메서드를 구현하는데 도움이 되는 메서드는 private로 선언
- 요약 : 관심을 갖는 클래스는 public 관심을 갖지않는 인스턴스 변수 및 보조 메서드는 private로 설정하여 클래스 내부에서만 볼 수 있게 만듦.

Instance Variable lifetime

- 변수가 속한 객체의 수명과 일치한다. 
- 객체가 생성되는 순간 생성.
- 참조가 없으면 Gabage Collector를 통해 자동으로 삭제한다.

This -> invocation Object이다.

인스턴스 변수와 지역변수를 구별하기 위해 사용.

Static Method 사용 할 때 
- 변화를 가정하지 않는다.
- 메소드가 인스턴스 변수를 사용하지 않는다.
- 인스턴스 생성에 의존하지 않는다.
- 메소드가 공유되고 있다면, 정적 메소드로 추출해낼 수 있다.
- 메소드가 변화되지 않고, 오버라이딩 되지 않는다.

Inheritance
- 이미 존재하는 클래스와 동일한 속성을 가지지만 새 기능을 추가하려는 클래스를 정의 하는 것 이다.
- Student -> Person의 하위 클래스이다.
- Person -> Student의 슈퍼 클래스이다.
- 슈퍼 클래스의 모든 메서드와 모든 인스턴스 변수를 상속할 수있다. -> 슈퍼 클래스의 메서드를 사용 할 수 있다.
- 반대로 슈퍼클래스는 하위 클래스의 메서드는 사용할 수 없다.
- Student 객체를 사용하는 파라미터가 있을 경우 이 때는 슈퍼클래스를 actual parameter로 설정 불가능하다.

Method Overriding
- 슈퍼클래스 메서드와 정확히 동일한 시그니쳐를 갖는 메서드를 서브클래스에 정의 할 때 메소드의 오버라이딩이라 한다.
- Polymorphism(다형성)이 생긴다.
- 정적 메서드는 오버라이딩을 할 수 없다.

Late binding
1. 바인딩 -> 각종 값들이 확정되어 더 이상 변경할 수 없는 상태가 되는 것
2. Late binding은 객체를 나타내는 유형의 메서드가 아닌 객체가 속한 클래스를 기반으로 메서드가 사용 되는 것
3. toString()은 late binding을 기반으로 이루어진다. 
 	-> toString을 나타내는 유형 - Object
	-> 객체가 속한 클래스 - Person